# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:05:16+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, RootModel


class Type(Enum):
    TRIANGLE_FAN = 'TRIANGLE_FAN'
    INDEXED_TRIANGLES = 'INDEXED_TRIANGLES'
    TRIANGLE_STRIP = 'TRIANGLE_STRIP'


class BasemapZOrder(BaseModel):
    zGrade: Optional[int] = Field(
        None,
        description='The second most significant component of the ordering of a component to be rendered onto the basemap.',
    )
    zPlane: Optional[int] = Field(
        None,
        description='The most significant component of the ordering of a component to be rendered onto the basemap.',
    )
    zWithinGrade: Optional[int] = Field(
        None,
        description='The least significant component of the ordering of a component to be rendered onto the basemap.',
    )


class Type1(Enum):
    FEATURE_TYPE_UNSPECIFIED = 'FEATURE_TYPE_UNSPECIFIED'
    STRUCTURE = 'STRUCTURE'
    BAR = 'BAR'
    BANK = 'BANK'
    LODGING = 'LODGING'
    CAFE = 'CAFE'
    RESTAURANT = 'RESTAURANT'
    EVENT_VENUE = 'EVENT_VENUE'
    TOURIST_DESTINATION = 'TOURIST_DESTINATION'
    SHOPPING = 'SHOPPING'
    SCHOOL = 'SCHOOL'
    SEGMENT = 'SEGMENT'
    ROAD = 'ROAD'
    LOCAL_ROAD = 'LOCAL_ROAD'
    ARTERIAL_ROAD = 'ARTERIAL_ROAD'
    HIGHWAY = 'HIGHWAY'
    CONTROLLED_ACCESS_HIGHWAY = 'CONTROLLED_ACCESS_HIGHWAY'
    FOOTPATH = 'FOOTPATH'
    RAIL = 'RAIL'
    FERRY = 'FERRY'
    REGION = 'REGION'
    PARK = 'PARK'
    BEACH = 'BEACH'
    FOREST = 'FOREST'
    POLITICAL = 'POLITICAL'
    ADMINISTRATIVE_AREA1 = 'ADMINISTRATIVE_AREA1'
    LOCALITY = 'LOCALITY'
    SUBLOCALITY = 'SUBLOCALITY'
    WATER = 'WATER'


class Status(Enum):
    STATUS_OK = 'STATUS_OK'
    STATUS_OK_DATA_UNCHANGED = 'STATUS_OK_DATA_UNCHANGED'


class ProviderInfo(BaseModel):
    description: Optional[str] = Field(
        None,
        description='Attribution string for this provider. This string is not localized.',
    )


class RelationType(Enum):
    RELATION_TYPE_UNSPECIFIED = 'RELATION_TYPE_UNSPECIFIED'
    OCCUPIES = 'OCCUPIES'
    PRIMARILY_OCCUPIED_BY = 'PRIMARILY_OCCUPIED_BY'


class Relation(BaseModel):
    relatedFeatureIndex: Optional[int] = Field(
        None,
        description='Zero-based index to look up the related feature from the list of features in the tile.',
    )
    relationType: Optional[RelationType] = Field(
        None,
        description='Relation type between the origin feature to the related feature.',
    )


class RoadInfo(BaseModel):
    isPrivate: Optional[bool] = Field(
        None,
        description='Road has signage discouraging or prohibiting use by the general public. E.g., roads with signs that say "Private", or "No trespassing."',
    )


class Row(BaseModel):
    altitudeDiffs: Optional[List[int]] = Field(
        None,
        description='The difference between each successive pair of altitudes, from west to east. The first, westmost point, is just the altitude rather than a diff. The units are specified by the altitude_multiplier parameter above; the value in meters is given by altitude_multiplier * altitude_diffs[n]. The altitude row (in metres above sea level) can be reconstructed with: a[0] = altitude_diffs[0] * altitude_multiplier when n > 0, a[n] = a[n-1] + altitude_diffs[n-1] * altitude_multiplier.',
    )


class SecondDerivativeElevationGrid(BaseModel):
    altitudeMultiplier: Optional[float] = Field(
        None,
        description='A multiplier applied to the elements in the encoded data to extract the actual altitudes in meters.',
    )
    columnCount: Optional[int] = Field(
        None,
        description='The number of columns included in the encoded elevation data (i.e. the horizontal resolution of the grid).',
    )
    encodedData: Optional[str] = Field(
        None,
        description='A stream of elements each representing a point on the tile running across each row from left to right, top to bottom. There will be precisely horizontal_resolution * vertical_resolution elements in the stream. The elements are not the heights, rather the second order derivative of the values one would expect in a stream of height data. Each element is a varint with the following encoding: ------------------------------------------------------------------------| | Head Nibble | ------------------------------------------------------------------------| | Bit 0 | Bit 1 | Bits 2-3 | | Terminator| Sign (1=neg) | Least significant 2 bits of absolute error | ------------------------------------------------------------------------| | Tail Nibble #1 | ------------------------------------------------------------------------| | Bit 0 | Bit 1-3 | | Terminator| Least significant 3 bits of absolute error | ------------------------------------------------------------------------| | ... | Tail Nibble #n | ------------------------------------------------------------------------| | Bit 0 | Bit 1-3 | | Terminator| Least significant 3 bits of absolute error | ------------------------------------------------------------------------|',
    )
    rowCount: Optional[int] = Field(
        None,
        description='The number of rows included in the encoded elevation data (i.e. the vertical resolution of the grid).',
    )


class SegmentInfo(BaseModel):
    roadInfo: Optional[RoadInfo] = Field(
        None, description='Metadata for features with the ROAD FeatureType.'
    )


class TileCoordinates(BaseModel):
    x: Optional[int] = Field(None, description='Required. The x coordinate.')
    y: Optional[int] = Field(None, description='Required. The y coordinate.')
    zoom: Optional[int] = Field(
        None, description='Required. The Google Maps API zoom level.'
    )


class TriangleStrip(BaseModel):
    vertexIndices: Optional[List[int]] = Field(
        None,
        description='Index into the vertex_offset array representing the next vertex in the triangle strip.',
    )


class Vertex2DList(BaseModel):
    xOffsets: Optional[List[int]] = Field(
        None, description='List of x-offsets in local tile coordinates.'
    )
    yOffsets: Optional[List[int]] = Field(
        None, description='List of y-offsets in local tile coordinates.'
    )


class Vertex3DList(BaseModel):
    xOffsets: Optional[List[int]] = Field(
        None, description='List of x-offsets in local tile coordinates.'
    )
    yOffsets: Optional[List[int]] = Field(
        None, description='List of y-offsets in local tile coordinates.'
    )
    zOffsets: Optional[List[int]] = Field(
        None, description='List of z-offsets in local tile coordinates.'
    )


class ClientInfoPlatform(Enum):
    PLATFORM_UNSPECIFIED = 'PLATFORM_UNSPECIFIED'
    EDITOR = 'EDITOR'
    MAC_OS = 'MAC_OS'
    WINDOWS = 'WINDOWS'
    LINUX = 'LINUX'
    ANDROID = 'ANDROID'
    IOS = 'IOS'
    WEB_GL = 'WEB_GL'


class TerrainFormat(Enum):
    TERRAIN_FORMAT_UNKNOWN = 'TERRAIN_FORMAT_UNKNOWN'
    FIRST_DERIVATIVE = 'FIRST_DERIVATIVE'
    SECOND_DERIVATIVE = 'SECOND_DERIVATIVE'


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class TerrainFormats(RootModel[List[TerrainFormat]]):
    root: List[TerrainFormat]


class Area(BaseModel):
    basemapZOrder: Optional[BasemapZOrder] = Field(
        None,
        description='The z-order of this geometry when rendered on a flat basemap. Geometry with a lower z-order should be rendered beneath geometry with a higher z-order. This z-ordering does not imply anything about the altitude of the area relative to the ground, but it can be used to prevent z-fighting. Unlike Area.z_order this can be used to compare with Line.basemap_z_order, and in fact may yield more accurate rendering (where a line may be rendered beneath an area).',
    )
    hasExternalEdges: Optional[bool] = Field(
        None,
        description='True if the polygon is not entirely internal to the feature that it belongs to: that is, some of the edges are bordering another feature.',
    )
    internalEdges: Optional[List[int]] = Field(
        None,
        description='When has_external_edges is true, the polygon has some edges that border another feature. This field indicates the internal edges that do not border another feature. Each value is an index into the vertices array, and denotes the start vertex of the internal edge (the next vertex in the boundary loop is the end of the edge). If the selected vertex is the last vertex in the boundary loop, then the edge between that vertex and the starting vertex of the loop is internal. This field may be used for styling. For example, building parapets could be placed only on the external edges of a building polygon, or water could be lighter colored near the external edges of a body of water. If has_external_edges is false, all edges are internal and this field will be empty.',
    )
    loopBreaks: Optional[List[int]] = Field(
        None,
        description='Identifies the boundary loops of the polygon. Only set for INDEXED_TRIANGLE polygons. Each value is an index into the vertices array indicating the beginning of a loop. For instance, values of [2, 5] would indicate loop_data contained 3 loops with indices 0-1, 2-4, and 5-end. This may be used in conjunction with the internal_edges field for styling polygon boundaries. Note that an edge may be on a polygon boundary but still internal to the feature. For example, a feature split across multiple tiles will have an internal polygon boundary edge along the edge of the tile.',
    )
    triangleIndices: Optional[List[int]] = Field(
        None,
        description='When the polygon encoding is of type INDEXED_TRIANGLES, this contains the indices of the triangle vertices in the vertex_offsets field. There are 3 vertex indices per triangle.',
    )
    type: Optional[Type] = Field(
        None, description='The polygon encoding type used for this area.'
    )
    vertexOffsets: Optional[Vertex2DList] = Field(
        None, description='The vertices present in the polygon defining the area.'
    )
    zOrder: Optional[int] = Field(
        None,
        description='The z-ordering of this area. Areas with a lower z-order should be rendered beneath areas with a higher z-order. This z-ordering does not imply anything about the altitude of the line relative to the ground, but it can be used to prevent z-fighting during rendering on the client. This z-ordering can only be used to compare areas, and cannot be compared with the z_order field in the Line message. The z-order may be negative or zero. Prefer Area.basemap_z_order.',
    )


class ExtrudedArea(BaseModel):
    area: Optional[Area] = Field(
        None, description='The area representing the footprint of the extruded area.'
    )
    maxZ: Optional[int] = Field(
        None,
        description='The z-value in local tile coordinates where the extruded area ends.',
    )
    minZ: Optional[int] = Field(
        None,
        description='The z-value in local tile coordinates where the extruded area begins. This is non-zero for extruded areas that begin off the ground. For example, a building with a skybridge may have an extruded area component with a non-zero min_z.',
    )


class FirstDerivativeElevationGrid(BaseModel):
    altitudeMultiplier: Optional[float] = Field(
        None,
        description='A multiplier applied to the altitude fields below to extract the actual altitudes in meters from the elevation grid.',
    )
    rows: Optional[List[Row]] = Field(
        None,
        description='Rows of points containing altitude data making up the elevation grid. Each row is the same length. Rows are ordered from north to south. E.g: rows[0] is the north-most row, and rows[n] is the south-most row.',
    )


class Line(BaseModel):
    basemapZOrder: Optional[BasemapZOrder] = Field(
        None,
        description='The z-order of this geometry when rendered on a flat basemap. Geometry with a lower z-order should be rendered beneath geometry with a higher z-order. This z-ordering does not imply anything about the altitude of the area relative to the ground, but it can be used to prevent z-fighting. Unlike Line.z_order this can be used to compare with Area.basemap_z_order, and in fact may yield more accurate rendering (where a line may be rendered beneath an area).',
    )
    vertexOffsets: Optional[Vertex2DList] = Field(
        None, description='The vertices present in the polyline.'
    )
    zOrder: Optional[int] = Field(
        None,
        description='The z-order of the line. Lines with a lower z-order should be rendered beneath lines with a higher z-order. This z-ordering does not imply anything about the altitude of the area relative to the ground, but it can be used to prevent z-fighting during rendering on the client. In general, larger and more important road features will have a higher z-order line associated with them. This z-ordering can only be used to compare lines, and cannot be compared with the z_order field in the Area message. The z-order may be negative or zero. Prefer Line.basemap_z_order.',
    )


class ModeledVolume(BaseModel):
    strips: Optional[List[TriangleStrip]] = Field(
        None, description='The triangle strips present in this mesh.'
    )
    vertexOffsets: Optional[Vertex3DList] = Field(
        None,
        description='The vertices present in the mesh defining the modeled volume.',
    )


class TerrainTile(BaseModel):
    coordinates: Optional[TileCoordinates] = Field(
        None,
        description='The global tile coordinates that uniquely identify this tile.',
    )
    firstDerivative: Optional[FirstDerivativeElevationGrid] = Field(
        None,
        description='Terrain elevation data encoded as a FirstDerivativeElevationGrid. cs/symbol:FirstDerivativeElevationGrid.',
    )
    name: Optional[str] = Field(
        None,
        description="Resource name of the tile. The tile resource name is prefixed by its collection ID `terrain/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `terrain/@1,2,3z`.",
    )
    secondDerivative: Optional[SecondDerivativeElevationGrid] = Field(
        None,
        description='Terrain elevation data encoded as a SecondDerivativeElevationGrid. cs/symbol:SecondDerivativeElevationGrid. See go/byte-encoded-terrain for more details.',
    )


class Geometry(BaseModel):
    areas: Optional[List[Area]] = Field(
        None, description='The areas present in this geometry.'
    )
    extrudedAreas: Optional[List[ExtrudedArea]] = Field(
        None,
        description='The extruded areas present in this geometry. Not populated if modeled_volumes are included in this geometry unless always_include_building_footprints is set in GetFeatureTileRequest, in which case the client should decide which (extruded areas or modeled volumes) should be used (they should not be rendered together).',
    )
    lines: Optional[List[Line]] = Field(
        None, description='The lines present in this geometry.'
    )
    modeledVolumes: Optional[List[ModeledVolume]] = Field(
        None,
        description='The modeled volumes present in this geometry. Not populated unless enable_modeled_volumes has been set in GetFeatureTileRequest.',
    )


class Feature(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='The localized name of this feature. Currently only returned for roads.',
    )
    geometry: Optional[Geometry] = Field(
        None,
        description='The geometry of this feature, representing the space that it occupies in the world.',
    )
    placeId: Optional[str] = Field(
        None,
        description='Place ID of this feature, suitable for use in Places API details requests.',
    )
    relations: Optional[List[Relation]] = Field(
        None, description='Relations to other features.'
    )
    segmentInfo: Optional[SegmentInfo] = Field(
        None, description='Metadata for features with the SEGMENT FeatureType.'
    )
    type: Optional[Type1] = Field(None, description='The type of this feature.')


class FeatureTile(BaseModel):
    coordinates: Optional[TileCoordinates] = Field(
        None,
        description='The global tile coordinates that uniquely identify this tile.',
    )
    features: Optional[List[Feature]] = Field(
        None, description='Features present on this map tile.'
    )
    name: Optional[str] = Field(
        None,
        description="Resource name of the tile. The tile resource name is prefixed by its collection ID `tiles/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `tiles/@1,2,3z`.",
    )
    providers: Optional[List[ProviderInfo]] = Field(
        None, description='Data providers for the data contained in this tile.'
    )
    status: Optional[Status] = Field(
        None, description='Tile response status code to support tile caching.'
    )
    versionId: Optional[str] = Field(
        None,
        description='An opaque value, usually less than 30 characters, that contains version info about this tile and the data that was used to generate it. The client should store this value in its tile cache and pass it back to the API in the client_tile_version_id field of subsequent tile requests in order to enable the API to detect when the new tile would be the same as the one the client already has in its cache. Also see STATUS_OK_DATA_UNCHANGED.',
    )
